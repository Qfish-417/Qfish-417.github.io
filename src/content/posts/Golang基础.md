---
title: Golang基础细节
published: 2025-04-05
description: 讲的是学习Go的时候应该搞懂的细节
image: ./cover.jpg
tags: [Golang, 基础]
category: Golang
draft: false
pinned: false
lang: zh-CN      # 仅当文章语言与 config.ts 中的站点语言不同时设置

---


# 1.1 与其他语言相比，使用 Go 有什么好处?

## 第一点

与其他语言不同，Go代码的设计是务实的，Go的语法更加简洁。每个功能和语法决策能够让程序员开发效率更高。

## 第二点

Golang针对并发进行了优化，支持协程，并且实现了高效的GMP调度模型（其中G是协程，P是逻辑处理器，M是内核线程）也可以解释为**<u>*Go 通过 GMP 模型在用户态实现了高效的协程调度：Goroutine 是执行单元，P 负责调度和维护队列，M 是真正的内核线程。M 必须绑定 P 才能执行 G。通过 work-stealing、本地队列、阻塞分离等机制，Go 实现了比传统线程更轻量、更高效的并发调度。*</u>**

## 第三点

由于单一的标准代码格式，Golang通常被认为比其他语言更具有可读性

## 第四点

有高效的垃圾回收机制，支持并行垃圾回收，垃圾回收效率比Java或Python更高

# 1.2 什么是协程？

用户态调度的轻量级执行单元

协程是一种由**<u>*用户态调度*</u>**的、比线程<u>***更轻量***</u>的执行单元。

它不由操作系统调度，而由语言运行时调度，可以在单个线程中运行**<u>*大量协程*</u>**，并以极低的成本进行切换。

#  1.3 协程和线程和进程的区别？

进程是 OS 资源分配单位，线程是 OS 调度的执行单位，而协程是运行时调度的轻量级执行单元。
 进程最重、线程中等、协程最轻；线程可并行，协程靠用户态调度实现高并发。

## 🔹 1️⃣ 进程（Process）

**核心概念**：操作系统分配资源的最小单位
 **特点**：

- 独立内存空间
- 创建/销毁成本高
- 切换开销大

**类比**：

> 想象成一栋独立的办公楼，每栋楼有自己的水电和网络。
>  想开新楼（进程），要重新建整个楼，成本很高。

------

## 🔹 2️⃣ 线程（Thread）

**核心概念**：操作系统调度的最小执行单位
 **特点**：

- 共享进程的内存资源
- 有自己的栈和寄存器
- 切换比进程快，但仍需要进入内核

**类比**：

> 每栋办公楼里有几个员工（线程），可以同时干活。
>  员工可以访问同一楼的资源（共享文件、网络），但是切换任务时需要 OS 去分配和调度。

------

## 🔹 3️⃣ 协程（Coroutine）

**核心概念**：用户态调度的轻量级执行单元
 **特点**：

- 不依赖 OS 调度，由语言运行时调度
- 栈小，可动态增长
- 切换开销非常低
- 可以在一个线程上跑成千上万个协程

**类比**：

> 员工手里的任务卡片就是协程。
>  一个员工（线程）手里可以同时处理很多小卡片（协程），切换卡片不需要走 OS，成本极低。
>  多个员工（线程）可以协作处理任务卡片，效率极高。

# 1.4 Golang 中 make 和 new 的区别？

`new(T)` 为类型 T 分配内存，返回 *T（指针），内容为零值；
 `make(T)` 仅用于 slice、map、channel，分配并初始化内部数据结构，返回可直接使用的 T

# 1.5 Golang 中数组和切片的区别？



> **数组定长值类型，拷贝传递；切片动态引用类型，灵活操作。**

------



> **数组是固定长度的值类型，赋值和传参会拷贝整个数组；切片是动态长度的引用类型，本质是对数组的窗口，赋值或传参只拷贝结构体，不拷贝底层数据，支持 append 扩容。**

# 1.6 使用for range 的时候，它的地址会发生变化吗？

# 1.7 如何高效地拼接字符串？

`for range` 会复用循环变量，因此它的地址在整个循环中保持不变。如果在循环中使用变量地址，要特别小心，会导致所有地址都一样。

“Go 里高效拼接字符串主要用 `strings。Builder`，因为它通过内部的可增长缓冲区避免重复分配；其次是 `bytes。Buffer`，底层基于 byte slice；大规模场景还可以用 byte slice append。直接用 `+` 或 fmt 拼接都会触发频繁分配，性能最差。

# 1.8 defer 的执行顺序是怎样的？defer 的作用或者使用场景是什么?

“defer 语句在函数返回前按后进先出的顺序执行。它的主要用途是资源清理，例如关闭文件、释放锁、回滚事务、记录耗时等。defer 注册时会计算参数值，执行时不会重新求值。大量 defer 有性能开销，应避免在循环中频繁使用。”

# 1.9 什么是 rune 类型？

rune 是 Go 中表示 Unicode 字符的类型，本质是 int32，用于处理多字节字符。

# 1.10 Go 语言 tag 有什么用？

Go 的 struct tag 是用反射读取的元数据，主要用于 JSON 编解码、数据库 ORM、参数绑定和字段验证等场景，用来告诉框架如何处理结构体字段

# 1.11 go 打印时 %v %+v %#v 的区别？

`%v` 是普通输出，`%+v` 会带上字段名，适合调试；`%#v` 会输出 Go 语法格式，包含类型信息，常用于结构体的深度调试或日志。

#  1.12 Go语言中空 struct{} 占用空间么？

空结构体不包含任何字段，因此不需要分配内存。

## 原因

因为结构体内部没有字段，也就没有：

- 不需要存储数据
- 不需要对齐（alignment）
- 不需要偏移量（offset）

Go 编译器就把它优化成：
 👉 **一个纯类型标签，没有实际数据占用。**

你甚至可以用反射验证：

```
fmt。Println(unsafe.Sizeof(struct{}{}))   // 0
```

## 那么不用空间有什么用？有哪些典型场景？


### **1️⃣ 作为 channel 的信号传递（最常用）**

因为不需要传数据，只需要“事件到了”的意思。

```
ch := make(chan struct{})

go func() {
    ch <- struct{}{}  // 发送信号
}()
<-ch // 等待信号
```

👍 **零拷贝、零成本信号类型**
 比用 `chan bool` 更节省空间。

------

### **2️⃣ 在 map 中充当“集合的 value”**

```
set := make(map[string]struct{})
set["abc"] = struct{}{}
```

为什么不用 bool？
 ✔ struct{} 更省内存（0 字节）
 ✔ 语义更准确：这是集合不是 key->value 映射

------

### **3️⃣ 用作方法接收器（逻辑上无需状态）**

```
type MyType struct{}  // 零成本类型

func (MyType) Do() {}
```

表示这个类型不需要保存任何信息，只是功能载体。

------

### **4️⃣ 限制内存分配**

比如生成器、通道池、worker 池时，只使用 struct{} 来节省空间。


> “Go 的空 struct 是零大小类型，占用 0 字节。常用于 channel 信号、map 集合、无状态类型、减少内存开销等场景，因为它完全不占空间，是最轻量的结构。”

#  1.13 Go语言中，空 struct{} 有什么用？

空 struct 不占内存，所以 Go 里常用于只需要占位或表示存在性、不需要实际数据的场景。典型用途包括：channel 信号、集合 map 的 value、无状态类型以及占位符，都是零开销的高效设计。

# 1.14 init() 函数是什么时候执行的？

`init()` 在程序运行前自动执行，在 `main()` 之前。每个包会先初始化全局变量，再执行 `init()`，并且按照包的依赖顺序从最底层包开始执行。

# 1.15 2 个 interface 可以比较吗 ？

可以比较，但前提是 interface 的底层动态类型是可比较类型。比较时 Go 会先比较动态类型，再比较值。如果底层是 slice/map/func 这种不可比较类型，直接在运行时报 panic。

# 1.16 2 个 nil 可能不相等吗？

可能不相等。interface在运行时绑定值，只有值为nil接口值才为nil，但是与指针的nil不相等

# 1.17 Go 语言函数传参是值类型还是引用类型？

Go 函数参数都是值传递，但有些类型（slice、map、chan、指针、interface）内部包含指向底层数据的指针，所以修改底层数据会影响原变量，这就是为什么它们看起来像引用传递。

# 1.18 如何知道一个对象是分配在栈上还是堆上？

Go 对象是否分配到堆或栈由逃逸分析决定。局部变量在函数内使用且不会逃逸通常分配到栈；如果对象会被函数外使用、传给接口或闭包引用，就会分配到堆，由 GC 管理。可以用 `go build -gcflags="-m"` 查看逃逸情况

# 1.19 Go语言的多返回值是如何实现的？

Go 多返回值是通过在调用者栈上为每个返回值预留空间实现的。函数执行完后，将每个返回值写入这些预留空间。对于小量返回值，编译器还会利用寄存器传递，提高性能。这比传统用 struct 返回更高效、更直接。

#  1.20 Go语言中"_"的作用

在 Go 中，`_` 是空白标识符，用来忽略不需要的值或变量。常见用法有：忽略函数返回值、忽略循环索引或 value、占位导入包执行 init、占位变量声明等。

# 1.21 Go语言普通指针和unsafe.Pointer有什么区别？

普通指针是类型安全的，只能指向特定类型；`unsafe.Pointer` 可以在任意类型之间转换，不做类型检查，通常用于底层内存操作或与 C 交互。使用 unsafe.Pointer 要格外小心，否则可能导致内存错乱或 panic

# 1.22 unsafe.Pointer与uintptr有什么区别和联系

`unsafe.Pointer` 是指针类型，保留了指针信息，会被 GC 追踪；`uintptr` 是整数类型，只保存地址值，不被 GC 追踪。两者可以互相转换，通常先把指针转成 uintptr 做运算，再转回 unsafe.Pointer，但要小心 GC，否则可能产生悬空指针。
